# Zaw Than, Student ID:#001368744


The Western Governors University Parcel Service (WGUPS)
------------------------------------------------------


A.      In this program (University Parcel Service), the "Greedy Algorithm" is used to load, and the "Nearest Neighbor Algorithm" is used to find the sorted route in delivering the packages.

B.2     This program is written with Python version 3.9 and PyCharm IDE in the local machine. CSV data files are stored in the same project.

B.4     In the case of the growing number of packages, there will be several series chains in the hash table because of fix capacity of the hash table. No matter what number of package is in a hash table, time complexity won't change in the worst-case scenario. It'll remain as O(N^2).

B.5     Program is split into classes with required functions. The code in this program is not slower than time complexity O(N^2). My program can be concluded as efficient and faster.
	    Appropriate comments, simple code structure, and descriptive variables names are used in the program. That is why my program is readable and easy to maintain.

B.6     The strengths of the self-adjusting data structures like a hash table could be as fast as constant time O(1) in inserting, searching, and removing data.
        The weaknesses of the self-adjusting data structures like a hash table could have collisions and it will slow down the speed to linear time O(N).

        The collision of a hash table can be solved in different methods as chaining, linear probing, quadratic probing, double hashing, and direct hashing.
        In the chaining hash table, hash table buckets are initialized as empty lists. In inserting, compute the bucket index and insert an item to the list at the computed index.
        In searching, compute the bucket index and return an item from the list. In removing, compute the bucket index and remove the item from the list.
        Since the hash table is large enough for all packages, there won't be a collision in my program.

D.      Self-adjusting data structure, such as a Chaining hash table can be used with the Greedy Algorithm which selects and loads packages to the truck.
        Because of fix capacity of the Chaining Hash Table, it has several chains in storing data at the hash table. It has to loop twice as a nested loop when transferring data. It will be slow in the speed of transferring data.

D.1     Chaining hash table can be constructed with desired capacity although default capacity is 10. The package's id is used as a key to creating a hash key. Inserting, searching, and removing packages by using a key is pretty fast as constant time.

I.1     (i) load_truck function uses the "Greedy Algorithm" which is quadratic time O(N^2).
        (ii) Able to select specific packages by different requirements and load multiple trucks simultaneously.

        (i) get_shortest_path function uses the "Nearest Neighbor algorithm" which is as fast as linear time O(N).
        (ii) Able to search the shortest distance of the current location and sort locations point by point for the entire truck route.

I.2     By using these two algorithms mentioned in part A, all deadlines meet the requirement and all truck mileages is under 140 miles.

I.3     "Activity selection problem algorithm", "Dijkstra's shortest path algorithm"

I.3.a   Activity selection problem algorithm sorts items in ascending order and keeps all selected items in a list.
        The activity selection problem algorithm could be used in selecting and loading packages to the truck. But it will require to modify or add a few steps of code to meet the current program requirement.

        Dijkstra's shortest path algorithm finds the shortest distance from a current vertex to neighborhood vertices in the graph.
        Dijkstra's shortest path could be used to find the next location of the delivery route. But, it is complex to implement and requires more code than the algorithm I use here.

J.      If I've extra time, I want to merge get_route and get_shortest_path functions to be more efficient and shorter code.

K.1.a   Increasing the number of packages will have several collisions in the hash table. In the chaining hash table, there will be a list for every same collision.
        The time complexity of searching a hash table will change from constant O(1) to linear O(N) in the worst-case scenario.

K.1.b   More space will be needed as an increasing number of packages to be delivered.
K.1.c   It will need more time if the number of cities changes and it will need more time for each truck if the number of trucks decreases as in linear time complexity.
        More cities will need more space. If more trucks, less space will be needed for each truck, and if fewer trucks, more space for each truck will be needed.

K.2     "Linear probing Hash Table", "Direct Hashing Table"
K.2.a   Linear probing Hash table uses the key as other hash tables do. In case of collision, it linearly searches subsequent buckets until an empty bucket is found.
        The direct hashing table uses the key directly as an index. There won't be collisions, but the hash table should be large enough for all items.



                 ***    The rest of requirements are in the code section.   ***